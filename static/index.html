<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>HackerChat</title>
<style>
  :root {
    --bg:#000; --ink:#0f0; --panel:#010; --line:#0f0;
  }
  * { box-sizing:border-box; }
  body { margin:0; font-family:monospace; background:var(--bg); color:var(--ink);}

  /* --- –•–µ–¥–µ—Ä –∏ –ª–µ–π–∞—É—Ç --- */
  #header { padding:10px; border-bottom:1px solid var(--line); background:var(--panel); display:flex; justify-content:space-between; align-items:center;}
  #container { display:flex; height:calc(100vh - 40px);}
  #users { width:240px; background:var(--panel); border-right:1px solid var(--line); overflow-y:auto;}
  #chat { flex:1; display:flex; flex-direction:column; }
  #topicBar { padding:8px 10px; border-bottom:1px solid var(--line); background:#000; font-weight:bold; }
  #messages { flex:1; padding:10px; overflow-y:auto; }
  #inputForm { display:flex; gap:6px; border-top:1px solid var(--line); padding:8px; }

  #inputForm input, #inputForm button { flex:1; }
  input, button {
    background:#000;
    color:var(--ink);
    border:1px solid var(--line);
    padding:6px 8px;
    font-family:monospace;
  }

  /* --- –ö–Ω–æ–ø–∫–∏ --- */
  button { cursor:pointer; background:#000; border:1px solid var(--line); transition: all .2s; }
  button:hover { background:#020; box-shadow:0 0 6px #0f0; }
  button:active { background:#040; }
  button[disabled] { opacity:.5; cursor:not-allowed; box-shadow:none; }

  /* --- –°–æ–æ–±—â–µ–Ω–∏—è –∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ --- */
  #messages .line { margin-bottom:6px; }
  #messages .me { color:#9f9; }
  #users .item { padding:8px 10px; border-bottom:1px solid #060; cursor:pointer; }
  #users .item.active { background:#020; font-weight:bold; }
  #users .item .tag { opacity:.8; font-size:12px; }
  .toolbar { display:flex; gap:8px; flex-wrap:wrap; }

  /* --- –ú–æ–¥–∞–ª–∫–∏ (–ª–æ–≥–∏–Ω/—Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è/–∞–¥–º–∏–Ω) --- */
  #loginForm, #registerForm, #adminForm {
    position:fixed;
    top:50%; left:50%;
    transform:translate(-50%, -50%);
    background:#000;
    border:1px solid var(--line);
    padding:20px;
    width:280px;
    text-align:center;
    box-shadow:0 0 12px #0f0;
    z-index:100;
  }
  .hidden { display:none; }

  /* --- –í–∏–¥–µ–æ–∑–≤–æ–Ω–æ–∫ --- */
  #videoPanel {
    position:fixed;
    bottom:10px; right:10px;
    background:#000;
    border:1px solid var(--line);
    padding:10px;
    display:flex;
    flex-direction:column;
    gap:6px;
    box-shadow:0 0 12px #0f0;
    z-index:50;
  }
  #videoPanel video {
    width:220px; height:160px;
    background:#111;
    border:1px solid var(--line);
    object-fit:cover;
  }
</style>
</head>
<body>

<div id="header">
  <span id="userInfo">Not logged in</span>
  <div class="toolbar">
    <button id="loginBtn">Login</button>
    <button id="adminBtn">Admin</button>
    <button id="logoutBtn" class="hidden">Logout</button>
    <button id="callBtn" class="hidden" title="Select a user to call" disabled>Call</button>
    <button id="hangupBtn" class="hidden">Hangup</button>
  </div>
</div>

<div id="container">
  <div id="users"></div>
  <div id="chat">
    <div id="topicBar">üåê Global chat</div>
    <div id="messages"></div>
    <form id="inputForm" class="hidden">
      <input id="messageInput" type="text" placeholder="Type a message‚Ä¶" autocomplete="off" />
      <button type="submit">Send</button>
    </form>
  </div>
</div>

<!-- –ü–∞–Ω–µ–ª—å –≤–∏–¥–µ–æ–∑–≤–æ–Ω–∫–∞ -->
<div id="videoPanel" class="hidden">
  <video id="localVideo" autoplay muted playsinline></video>
  <video id="remoteVideo" autoplay playsinline></video>
</div>

<!-- Auth Forms -->
<div id="loginForm" class="hidden">
  <h3>Login</h3>
  <input id="loginName" placeholder="Login"><br><br>
  <input id="loginPass" type="password" placeholder="Password"><br><br>
  <button type="button" onclick="doLogin()">Login</button>
  <button type="button" onclick="showRegister()">Register</button>
</div>

<div id="registerForm" class="hidden">
  <h3>Register</h3>
  <input id="regName" placeholder="Login"><br><br>
  <input id="regPass" type="password" placeholder="Password"><br><br>
  <button type="button" onclick="doRegister()">Register</button>
  <button type="button" onclick="showLogin()">Back</button>
</div>

<div id="adminForm" class="hidden">
  <h3>Admin</h3>
  <input id="adminPwd" type="password" placeholder="Password"><br><br>
  <button type="button" onclick="adminLogin()">Enter</button>
</div>

<script>
const SERVER = window.location.origin;

let currentUser = null;     // { user_id, username }
let adminPwd = null;
let selectedScope = "global";  // "global" | "dialog"
let selectedPeer = "all";      // "all" | user_id
let pollTimer = null;

/* ===================== UI helpers ===================== */
function showLogin(){ hideAll(); document.getElementById("loginForm").classList.remove("hidden"); }
function showRegister(){ hideAll(); document.getElementById("registerForm").classList.remove("hidden"); }
function showAdmin(){ hideAll(); document.getElementById("adminForm").classList.remove("hidden"); }
function hideAll(){ document.querySelectorAll("#loginForm,#registerForm,#adminForm").forEach(e=>e.classList.add("hidden")); }
function setTopic(text){ document.getElementById("topicBar").textContent = text; }
function setAuthUI(logged){
  document.getElementById("inputForm").classList.toggle("hidden", !logged);
  document.getElementById("logoutBtn").classList.toggle("hidden", !logged);
  document.getElementById("callBtn").classList.toggle("hidden", !logged);
  // Hangup button is controlled by showVideoUI
  updateCallButtons();
}
function updateCallButtons(){
  const callBtn = document.getElementById("callBtn");
  const canCall = !!currentUser && selectedScope==="dialog" && selectedPeer!=="all";
  callBtn.disabled = !canCall;
  callBtn.title = canCall ? "Start call" : "Select a user to call";
}
function el(tag, cls, text){
  const n = document.createElement(tag);
  if(cls) n.className = cls;
  if(text!=null) n.textContent = text;
  return n;
}

/* ===================== Auth ===================== */
async function doLogin(){
  const login = document.getElementById("loginName").value.trim();
  const pass  = document.getElementById("loginPass").value;
  const r = await fetch(SERVER+"/login", {
    method:"POST", headers:{"Content-Type":"application/json"},
    body: JSON.stringify({login, password: pass})
  });
  const d = await r.json();
  if(d.error){ alert(d.error); return; }
  currentUser = d;
  document.getElementById("userInfo").textContent = "Logged as " + d.username;
  setAuthUI(true);
  hideAll();
  await refreshUsers();
  selectGlobal();
  startPolling();
  connectWS(); // –ø–æ–¥–∫–ª—é—á–∞–µ–º WS –¥–ª—è —Å–∏–≥–Ω–∞–ª–∏–Ω–≥–∞ –∑–≤–æ–Ω–∫–æ–≤
}

async function doRegister(){
  const login = document.getElementById("regName").value.trim();
  const pass  = document.getElementById("regPass").value;
  const r = await fetch(SERVER+"/register", {
    method:"POST", headers:{"Content-Type":"application/json"},
    body: JSON.stringify({login, password: pass})
  });
  const d = await r.json();
  if(d.error){ alert(d.error); return; }
  alert("Registered. Now login.");
  showLogin();
}

async function doLogout(){
  stopPolling();
  disconnectWS();
  hangup(); // –Ω–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π –∑–∞–∫—Ä—ã—Ç—å —Å—Ç—Ä–∏–º—ã –∏ —Å–±—Ä–æ—Å–∏—Ç—å WebRTC
  currentUser = null;
  selectedScope = "global";
  selectedPeer = "all";
  document.getElementById("userInfo").textContent = "Not logged in";
  document.getElementById("messages").innerHTML = "";
  document.getElementById("users").innerHTML = "";
  setTopic("üåê Global chat");
  setAuthUI(false);
  showLogin();
}

/* ===================== Users ===================== */
async function refreshUsers(){
  if(!currentUser) return;
  const r = await fetch(SERVER + "/users?exclude_id=" + encodeURIComponent(currentUser.user_id));
  const d = await r.json();
  const box = document.getElementById("users");
  box.innerHTML = "";

  // Global chat item
  const globalItem = el("div", "item" + (selectedPeer==="all" ? " active" : ""), "üåê Global chat");
  globalItem.onclick = selectGlobal;
  box.appendChild(globalItem);

  // Users
  d.users.forEach(u=>{
    const item = el("div", "item" + (selectedPeer===u.id ? " active" : ""), u.username);
    const tag = el("div", "tag", u.id);
    item.appendChild(tag);
    item.onclick = ()=> selectPeer(u.id, u.username);
    box.appendChild(item);
  });
  updateCallButtons();
}

function markActivePeer(){
  const items = document.querySelectorAll("#users .item");
  items.forEach(i => i.classList.remove("active"));
  if(selectedPeer==="all"){
    items[0]?.classList.add("active");
  } else {
    items.forEach(i=>{
      const idDiv = i.querySelector(".tag");
      if(idDiv && idDiv.textContent === selectedPeer) i.classList.add("active");
    });
  }
}

function selectGlobal(){
  selectedScope = "global";
  selectedPeer  = "all";
  setTopic("üåê Global chat");
  markActivePeer();
  loadMessages(true);
  updateCallButtons();
}

function selectPeer(userId, username){
  selectedScope = "dialog";
  selectedPeer  = userId;
  setTopic("üí¨ Chat with: " + username);
  markActivePeer();
  loadMessages(true);
  updateCallButtons();
}

/* ===================== Messages ===================== */
async function loadMessages(forceScroll=false){
  if(!currentUser) return;
  let url = SERVER + "/messages?limit=200";
  if(selectedScope === "global"){
    url += "&scope=global";
  } else {
    url += "&scope=dialog&user_id=" + encodeURIComponent(currentUser.user_id) +
           "&peer_id=" + encodeURIComponent(selectedPeer);
  }

  const r = await fetch(url);
  if(!r.ok) return;
  const list = await r.json();
  const box = document.getElementById("messages");
  const atBottom = box.scrollTop + box.clientHeight >= box.scrollHeight - 20;

  box.innerHTML = "";
  list.forEach(m=>{
    const who = (m.sender_id === currentUser.user_id) ? "You" : (m.sender_name || m.sender_id);
    const line = el("div", "line" + (who==="You" ? " me" : ""), `${who}: ${m.text}`);
    box.appendChild(line);
  });

  if(forceScroll || atBottom){
    box.scrollTop = box.scrollHeight;
  }
}

document.getElementById("inputForm").onsubmit = async (e)=>{
  e.preventDefault();
  if(!currentUser) return;
  const inp = document.getElementById("messageInput");
  const text = inp.value.trim();
  if(!text) return;
  const payload = {
    sender_id: currentUser.user_id,
    recipient: (selectedScope==="global" ? "all" : selectedPeer),
    text
  };
  await fetch(SERVER+"/send", {
    method:"POST", headers:{"Content-Type":"application/json"},
    body: JSON.stringify(payload)
  });
  inp.value = "";
  loadMessages(true);
};

/* ===================== Polling ===================== */
function startPolling(){
  stopPolling();
  pollTimer = setInterval(()=>{
    loadMessages(false);
    refreshUsers();
  }, 1500);
}
function stopPolling(){
  if(pollTimer){ clearInterval(pollTimer); pollTimer = null; }
}

/* ===================== Admin ===================== */
async function adminLogin(){
  const pwd = document.getElementById("adminPwd").value;
  const r = await fetch(SERVER+"/admin/login",{
    method:"POST", headers:{"Content-Type":"application/json"},
    body: JSON.stringify({password: pwd})
  });
  const d = await r.json();
  if(d.error){ alert(d.error); return; }
  adminPwd = pwd;
  loadAdmin();
}

async function loadAdmin(){
  const r = await fetch(SERVER+"/admin/users?password="+encodeURIComponent(adminPwd));
  const d = await r.json();
  if(d.error){ alert(d.error); return; }
  let html = "<h3>Admin Panel</h3><div class='toolbar'>"+
             "<button onclick='resetDB()'>Reset DB</button></div><ul>";
  d.users.forEach(u=>{
    html += `<li>${u.username} ‚Äî messages: ${u.messages}</li>`;
  });
  html += "</ul>";
  document.getElementById("adminForm").innerHTML = html;
}

async function resetDB(){
  const r = await fetch(SERVER+"/admin/reset",{
    method:"POST", headers:{"Content-Type":"application/json"},
    body: JSON.stringify({password: adminPwd})
  });
  const d = await r.json();
  alert(JSON.stringify(d));
  loadAdmin();
}

/* ===================== WebRTC / Calls ===================== */
let ws = null;
let peerConnection = null; // Renamed 'pc' to 'peerConnection' for clarity
let localStream = null;
let remoteStream = null;
let currentCallingPeerId = null; // Renamed 'peerId' to 'currentCallingPeerId' to avoid confusion with selectedPeer

const iceServers = {
  iceServers: [
    { urls: 'stun:stun.l.google.com:19302' },
    // You can add more STUN/TURN servers here for better reliability
    // { urls: 'turn:your.turn.server.com:3478', username: 'user', credential: 'password' }
  ]
};

function wsURL(){
  const proto = location.protocol === 'https:' ? 'wss' : 'ws';
  return `${proto}://${location.host}/ws/call/${currentUser.user_id}`;
}

function connectWS(){
  if(!currentUser || ws) return;
  ws = new WebSocket(wsURL());
  ws.onopen = () => {
      console.log("WebSocket connected for calls.");
  };
  ws.onmessage = async (event)=>{
    const msg = JSON.parse(event.data);
    console.log("WS message received:", msg); // Debugging
    if(msg.type==="offer"){ await handleOffer(msg); }
    else if(msg.type==="answer"){ await handleAnswer(msg); } // New handler for answer
    else if(msg.type==="candidate"){ await handleIceCandidate(msg); } // New handler for candidate
    else if(msg.type==="error"){ alert("Call error: " + msg.message); hangup(); }
  };
  ws.onclose = ()=>{
    console.log("WebSocket disconnected for calls.");
    ws = null;
  };
  ws.onerror = (error) => {
    console.error("WebSocket error:", error);
  };
}
function disconnectWS(){
  if(ws){ try{ ws.close(); }catch(e){} ws=null; }
}

async function startCall(){
  if(selectedPeer==="all"){ alert("Select a user for the call."); return; }
  currentCallingPeerId = selectedPeer; // Set the peer we are calling
  await ensurePeerConnection();

  try {
    const offer = await peerConnection.createOffer();
    await peerConnection.setLocalDescription(offer);
    ws?.send(JSON.stringify({to:currentCallingPeerId, type:"offer", data:offer}));
    console.log("Sent offer to", currentCallingPeerId);
    showVideoUI(true);
  } catch (err) {
    console.error("Error creating or sending offer:", err);
    alert("Failed to start call: " + err);
    hangup();
  }
}

async function handleOffer(msg){
  // Check if we are already in a call or trying to call someone else
  if (peerConnection && currentCallingPeerId && currentCallingPeerId !== msg.from) {
      console.warn("Already in a call or calling someone else, ignoring incoming offer.");
      // Optionally, send a "busy" message back
      ws?.send(JSON.stringify({ to: msg.from, type: "error", message: "User busy" }));
      return;
  }
  
  currentCallingPeerId = msg.from; // The sender of the offer is the peer we are connecting to
  await ensurePeerConnection();

  try {
    await peerConnection.setRemoteDescription(new RTCSessionDescription(msg.data));
    const answer = await peerConnection.createAnswer();
    await peerConnection.setLocalDescription(answer);
    ws?.send(JSON.stringify({to:currentCallingPeerId, type:"answer", data:answer}));
    console.log("Sent answer to", currentCallingPeerId);
    showVideoUI(true);
  } catch (err) {
    console.error("Error handling offer or sending answer:", err);
    alert("Failed to answer call: " + err);
    hangup();
  }
}

async function handleAnswer(msg) {
  if (!peerConnection) {
    console.warn("No peer connection to set answer on.");
    return;
  }
  try {
    await peerConnection.setRemoteDescription(new RTCSessionDescription(msg.data));
    console.log("Received and set answer from", msg.from);
  } catch (err) {
    console.error("Error setting remote description from answer:", err);
    alert("Failed to process answer: " + err);
    hangup();
  }
}

async function handleIceCandidate(msg) {
  if (!peerConnection) {
    console.warn("No peer connection to add ICE candidate to.");
    return;
  }
  try {
    await peerConnection.addIceCandidate(new RTCIceCandidate(msg.data));
    console.log("Added ICE candidate from", msg.from);
  } catch (err) {
    console.error("Error adding ICE candidate:", err);
    // This can happen if candidates arrive before remote description is set.
    // WebRTC usually handles this by queueing, but a warning is good.
  }
}

async function ensurePeerConnection(){
  if(peerConnection) return; // If peerConnection already exists, do nothing

  peerConnection = new RTCPeerConnection(iceServers); // Pass ICE servers here!
  console.log("New RTCPeerConnection created.");

  peerConnection.onicecandidate = e => {
    if (e.candidate) {
      console.log("Sending ICE candidate:", e.candidate);
      ws?.send(JSON.stringify({to:currentCallingPeerId, type:"candidate", data:e.candidate}));
    }
  };

  // Handle incoming media streams
  peerConnection.ontrack = e => {
    console.log("Remote track received:", e.streams);
    if (e.streams && e.streams[0]) {
      const remoteVideo = document.getElementById("remoteVideo");
      // Assign the first stream to the video element
      if (remoteVideo.srcObject !== e.streams[0]) {
        remoteVideo.srcObject = e.streams[0];
        console.log("Remote stream assigned to remoteVideo.");
      }
    }
  };

  // Get local media
  if(!localStream){
    try{
      localStream = await navigator.mediaDevices.getUserMedia({video:true,audio:true});
      console.log("Local media stream obtained.");
    }catch(err){
      alert("Camera/mic error: " + err + ". Make sure you grant permissions.");
      console.error("getUserMedia error:", err);
      hangup(); // Hang up if media access fails
      return;
    }
  }
  localStream.getTracks().forEach(t => peerConnection.addTrack(t, localStream));
  document.getElementById("localVideo").srcObject = localStream;
  console.log("Local stream assigned to localVideo and tracks added to peerConnection.");

  // Debugging connection state changes
  peerConnection.oniceconnectionstatechange = () => {
    console.log('ICE connection state changed:', peerConnection.iceConnectionState);
    if (peerConnection.iceConnectionState === 'failed' || peerConnection.iceConnectionState === 'closed') {
        console.warn('ICE connection failed or closed. Attempting hangup.');
        hangup(); // Automatically hangup on connection failure
    }
  };
  peerConnection.onconnectionstatechange = () => {
    console.log('Peer connection state changed:', peerConnection.connectionState);
    if (peerConnection.connectionState === 'disconnected' || peerConnection.connectionState === 'closed' || peerConnection.connectionState === 'failed') {
        console.warn('Peer connection disconnected, closed, or failed. Attempting hangup.');
        hangup();
    }
  };
}


function showVideoUI(visible){
  document.getElementById("videoPanel").classList.toggle("hidden", !visible);
  // Ensure hangup button is only visible when video panel is
  document.getElementById("hangupBtn").classList.toggle("hidden", !visible);
  // Call button should be disabled while a call is active (or trying to connect)
  document.getElementById("callBtn").disabled = visible;
}

function hangup(){
  console.log("Hanging up call.");
  if(peerConnection){
    try{
      peerConnection.ontrack = null;
      peerConnection.onicecandidate = null;
      peerConnection.oniceconnectionstatechange = null;
      peerConnection.onconnectionstatechange = null;
      peerConnection.close();
      console.log("PeerConnection closed.");
    }catch(e){ console.error("Error closing peerConnection:", e); }
    peerConnection = null;
  }
  if(localStream){
    localStream.getTracks().forEach(t => t.stop());
    document.getElementById("localVideo").srcObject = null;
    localStream = null;
    console.log("Local stream stopped.");
  }
  // remoteStream doesn't need to be stopped like localStream, just nullified from video element
  if(document.getElementById("remoteVideo").srcObject){
    document.getElementById("remoteVideo").srcObject = null;
  }
  remoteStream = null; // No need to stop individual tracks if not holding references
  currentCallingPeerId = null;
  showVideoUI(false); // Hide the video panel and hangup button
  updateCallButtons(); // Re-enable call button if eligible
}

/* ===================== Header buttons ===================== */
document.getElementById("loginBtn").onclick = showLogin;
document.getElementById("adminBtn").onclick = showAdmin;
document.getElementById("logoutBtn").onclick = doLogout;
document.getElementById("callBtn").onclick = startCall;
document.getElementById("hangupBtn").onclick = hangup;

/* ===================== —Å—Ç–∞—Ä—Ç ===================== */
showLogin();
</script>

</body>
</html>
